<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</h1>
            <p class="text-gray-600">Secure Russian Polygraphic Cipher</p>
        </header>

        <!-- –°–µ–∫—Ü–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º —à–∏—Ñ—Ä–∞ -->
        <div class="mb-6 bg-white rounded-lg shadow overflow-hidden">
            <div class="bg-blue-500 text-white p-4 cursor-pointer" onclick="toggleCipherInfo()">
                <div class="flex justify-between items-center">
                    <h2 class="text-xl font-bold">–û —à–∏—Ñ—Ä–µ SRPC</h2>
                    <svg id="cipher-arrow" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
            </div>
            <div id="cipher-info" class="p-4 space-y-3 hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-800">üìä –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li><strong>–¢–∏–ø:</strong> –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –±–ª–æ—á–Ω—ã–π —à–∏—Ñ—Ä</li>
                            <li><strong>–†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞:</strong> 16 —Å–∏–º–≤–æ–ª–æ–≤</li>
                            <li><strong>–†–µ–∂–∏–º:</strong> CBC (Cipher Block Chaining)</li>
                            <li><strong>–†–∞—É–Ω–¥—ã:</strong> 12 —Ä–∞—É–Ω–¥–æ–≤ Feistel —Å–µ—Ç–∏</li>
                            <li><strong>–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è:</strong> HMAC-SHA256</li>
                            <li><strong>–î–ª–∏–Ω–∞ –∫–ª—é—á–∞:</strong> –æ—Ç 8 —Å–∏–º–≤–æ–ª–æ–≤</li>
                        </ul>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold text-gray-800">üîë –ö–ª—é—á–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li><strong>Cipher Key:</strong> 32 –±–∞–π—Ç–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</li>
                            <li><strong>MAC Key:</strong> 32 –±–∞–π—Ç–∞ –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏</li>
                            <li><strong>–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ:</strong> Base36 —Å –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–æ–π</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è –≤–≤–æ–¥–∞ -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ -->
            <div class="space-y-6">
                <!-- –ü–æ–ª–µ –¥–ª—è —Ç–µ–∫—Å—Ç–∞ -->
                <div class="bg-white rounded-lg shadow">
                    <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                        –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:
                    </label>
                    <textarea 
                        id="inputText" 
                        placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..."
                        class="w-full h-48 p-4 outline-none resize-none"
                    ></textarea>
                </div>

                <!-- –ü–æ–ª–µ –¥–ª—è –∫–ª—é—á–∞ -->
                <div class="bg-white rounded-lg shadow">
                    <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                        –ú–∞—Å—Ç–µ—Ä-–∫–ª—é—á:
                        <span class="text-xs font-normal text-gray-500 ml-1">
                            (–º–∏–Ω. 8 —Å–∏–º–≤–æ–ª–æ–≤, —Å–µ–π—á–∞—Å: <span id="key-length">0</span>)
                        </span>
                    </label>
                    <div class="p-4">
                        <input 
                            type="text" 
                            id="masterKey" 
                            value="test_reversibility_extended_key_has_crypto"
                            placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (–º–∏–Ω–∏–º—É–º 20 —Å–∏–º–≤–æ–ª–æ–≤)"
                            class="w-full p-3 border border-gray-300 rounded-md"
                            oninput="updateKeyLength()"
                        >
                        
                        <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–ª—é—á–æ–º -->
                        <div class="mt-3 grid grid-cols-2 gap-2">
                            <button 
                                onclick="saveKey()"
                                class="px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üíæ</span>
                                <span>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</span>
                            </button>
                            <button 
                                onclick="loadKey()"
                                class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üìÇ</span>
                                <span>–ó–∞–≥—Ä—É–∑–∏—Ç—å</span>
                            </button>
                            <button 
                                onclick="generateRandomKey()"
                                class="px-3 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üé≤</span>
                                <span>–°–ª—É—á–∞–π–Ω—ã–π</span>
                            </button>
                            <button 
                                onclick="clearKey()"
                                class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üóëÔ∏è</span>
                                <span>–û—á–∏—Å—Ç–∏—Ç—å</span>
                            </button>
                        </div>

                        <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –∫–æ—Ä–æ—Ç–∫–æ–º –∫–ª—é—á–µ -->
                        <div id="key-warning" class="mt-2 text-sm text-red-600 text-center hidden">
                            ‚ö†Ô∏è –ö–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π! –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ - 8 —Å–∏–º–≤–æ–ª–æ–≤.
                        </div>
                    </div>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
            <div class="space-y-6">
                <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å—Ç–∞—Ç—É—Å -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="space-y-4">
                        <!-- –†–µ–∂–∏–º -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">–†–µ–∂–∏–º:</label>
                            <select id="srpcMode" class="w-full p-2 border border-gray-300 rounded-md">
                                <option value="encrypt">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                                <option value="decrypt">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                            </select>
                        </div>

                        <!-- –ö–Ω–æ–ø–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è -->
                        <div class="flex space-x-3">
                            <button 
                                id="processBtn"
                                onclick="processSRPC()"
                                disabled
                                class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
                            </button>
                            <button 
                                onclick="clearAll()"
                                class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors"
                            >
                                –û—á–∏—Å—Ç–∏—Ç—å
                            </button>
                        </div>

                        <!-- –°—Ç–∞—Ç—É—Å –∫–ª—é—á–µ–π -->
                        <div id="key-status" class="text-sm text-center p-2 rounded hidden"></div>
                    </div>
                </div>

           </div>
        </div>

        <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç -->
        <div class="bg-white rounded-lg shadow mb-6">
            <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                –†–µ–∑—É–ª—å—Ç–∞—Ç:
            </label>
            <textarea 
                id="outputText" 
                placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç..."
                readonly
                class="w-full h-48 p-4 outline-none resize-none font-mono text-sm"
            ></textarea>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏ -->
        <div id="status-message" class="mb-4 p-4 rounded-lg hidden">
            <p class="text-sm font-medium" id="status-text"></p>
        </div>

        <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è -->
        <div class="flex justify-center space-x-4">
            <button 
                onclick="copyToClipboard()"
                class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors"
            >
                –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            </button>
            <button 
                onclick="swapTexts()"
                class="px-6 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors"
            >
                –ü–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
            </button>
        </div>

   </div>

    <script>
        let pyodide;
        let srpcModule;
        const minLength = 8;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Pyodide
        async function initializePyodide() {
            try {
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/",
                    stdout: () => {},
                    stderr: () => {},
                    fullStdLib: false
                });
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º micropip –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–æ–≤
                await pyodide.loadPackage("micropip");
                const micropip = pyodide.pyimport("micropip");
                
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º SRPC –∫–æ–¥
                await loadSRPCCode();
                
                document.getElementById('processBtn').disabled = false;
            } catch (error) {
                console.error('Pyodide initialization error:', error);
            }
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ SRPC –∫–æ–¥–∞
        async function loadSRPCCode() {
            try {
                // –í–∞—à –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π Python –∫–æ–¥
                const srpcCode = `
import hmac
import secrets
from hashlib import sha256

class SRPC:
    def __init__(self, key: str):
        if not key:
            raise ValueError("–ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
        self.master_key = key.encode('utf-8')

        # –í—Ö–æ–¥–Ω–æ–π –∞–ª—Ñ–∞–≤–∏—Ç (162 —Å–∏–º–≤–æ–ª–∞)
        self.plain_alphabet = (
            "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø"
            "–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz"
            "0123456789 \\n"
            + "!\\"#$%&'()*+,-./:;<=>?@[\\\\]^_\`{|}~"
        )
        self.alphabet_size = len(self.plain_alphabet)
        self.base36 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        self.base36_size = 36

        # üöÄ –£–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä –±–ª–æ–∫–∞ —Å 4 –¥–æ 16 —Å–∏–º–≤–æ–ª–æ–≤
        self.block_size = 16
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞: 162^16 <= 36^24?
        if self.alphabet_size ** self.block_size > self.base36_size ** 24:
            raise ValueError("–ê–ª—Ñ–∞–≤–∏—Ç —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫ –¥–ª—è 16‚Üí24 —Å—Ö–µ–º—ã")

        # üöÄ –£—Å–∏–ª–µ–Ω–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ —Å —Å–æ–ª—è–º–∏
        salt = "srpc_v2_salt_2024_secure_random_bytes"
        salted_key = key + salt
        self.cipher_key = hmac.new(salted_key.encode('utf-8'), b"cipher_key_derivation", sha256).digest()
        self.mac_key = hmac.new(salted_key.encode('utf-8'), b"mac_key_derivation", sha256).digest()

        # –ü–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π –∞–ª—Ñ–∞–≤–∏—Ç
        self.shuffled_alphabet = self._shuffle_alphabet(self.plain_alphabet, self.cipher_key)
        # S-Box: –∏–Ω–¥–µ–∫—Å -> –∏–Ω–¥–µ–∫—Å (–ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞)
        self.sbox = self._generate_sbox(self.cipher_key)

    def _shuffle_alphabet(self, alphabet: str, key_material: bytes) -> str:
        letters = list(alphabet)
        n = len(letters)
        key_bytes = list(key_material)
        for i in range(n - 1, 0, -1):
            j = key_bytes[i % len(key_bytes)] % (i + 1)
            letters[i], letters[j] = letters[j], letters[i]
        return ''.join(letters)

    def _generate_sbox(self, key_material: bytes) -> list[int]:
        indices = list(range(self.alphabet_size))
        n = len(indices)
        key_bytes = list(key_material)
        for i in range(n - 1, 0, -1):
            j = key_bytes[i % len(key_bytes)] % (i + 1)
            indices[i], indices[j] = indices[j], indices[i]
        return indices

    def _to_base36(self, num: int) -> str:
        if num == 0:
            return self.base36[0]
        s = ""
        while num:
            s = self.base36[num % self.base36_size] + s
            num //= self.base36_size
        return s

    def _from_base36(self, s: str) -> int:
        num = 0
        for ch in s:
            if 'A' <= ch <= 'Z':
                val = ord(ch) - ord('A')
            else:
                val = ord(ch) - ord('0') + 26
            num = num * self.base36_size + val
        return num

    def _pad(self, text: str, block_size: int) -> str:
        pad_len = block_size - (len(text) % block_size)
        if pad_len == 0:
            pad_len = block_size
        padding_char = self.shuffled_alphabet[(pad_len - 1) % self.alphabet_size]
        return text + (padding_char * pad_len)

    def _unpad(self, text: str) -> str:
        if not text:
            return text
        last_char = text[-1]
        try:
            pad_idx = self.shuffled_alphabet.index(last_char)
        except ValueError:
            raise ValueError(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–∞–¥–¥–∏–Ω–≥–∞ {last_char}")
        pad_len = pad_idx + 1

        if pad_len < 1 or pad_len > self.block_size:
            raise ValueError(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –ø–∞–¥–¥–∏–Ω–≥–∞ {pad_len} > {self.block_size}")

        if len(text) < pad_len or text[-pad_len:] != last_char * pad_len:
            raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–∞–¥–¥–∏–Ω–≥")

        return text[:-pad_len]

    def _text_to_blocks(self, text: str, block_size: int) -> list[str]:
        padded = self._pad(text, block_size)
        return [padded[i:i+block_size] for i in range(0, len(padded), block_size)]

    def _blocks_to_text(self, blocks: list[str]) -> str:
        text = ''.join(blocks)
        return self._unpad(text)

    def _apply_sbox(self, ch: str) -> str:
        idx = self.shuffled_alphabet.index(ch)
        new_idx = self.sbox[idx]
        return self.shuffled_alphabet[new_idx]

    def _apply_inverse_sbox(self, ch: str) -> str:
        idx = self.shuffled_alphabet.index(ch)
        for i, v in enumerate(self.sbox):
            if v == idx:
                orig_idx = i
                break
        return self.shuffled_alphabet[orig_idx]

    def _mix_blocks(self, block: str, prev: str) -> str:
        alphabet = self.shuffled_alphabet
        n = self.alphabet_size
        result = ''
        for i in range(len(block)):
            idx1 = alphabet.index(block[i])
            idx2 = alphabet.index(prev[i])
            mixed_idx = (idx1 + idx2) % n
            result += alphabet[mixed_idx]
        return result

    def _unmix_blocks(self, mixed: str, prev: str) -> str:
        alphabet = self.shuffled_alphabet
        n = self.alphabet_size
        result = ''
        for i in range(len(mixed)):
            idx1 = alphabet.index(mixed[i])
            idx2 = alphabet.index(prev[i])
            plain_idx = (idx1 - idx2) % n
            result += alphabet[plain_idx]
        return result

    def _feistel_round(self, left: str, right: str, round_key: bytes, round_num: int) -> tuple[str, str]:
        combined = right.encode('utf-8') + round_key
        prf_output = hmac.new(self.cipher_key, combined, sha256).digest()
        prf_num = int.from_bytes(prf_output, 'big')

        new_left = ''
        for ch in left:
            sboxed_ch = self._apply_sbox(ch)
            idx = self.shuffled_alphabet.index(sboxed_ch)
            
            round_factor = (round_num + 1) % self.alphabet_size
            if round_factor == 0:
                round_factor = 1
            shift = (prf_num * round_factor) % self.alphabet_size
            new_idx = (idx + shift) % self.alphabet_size
            new_left += self.shuffled_alphabet[new_idx]
            
        return right, new_left

    def _feistel_encrypt_block(self, block: str) -> str:
        mid = len(block) // 2
        left = block[:mid]
        right = block[mid:]
        
        for i in range(12):
            round_key = self.cipher_key[:16] + i.to_bytes(4, 'big')
            left, right = self._feistel_round(left, right, round_key, i)
        return left + right

    def _feistel_decrypt_block(self, block: str) -> str:
        mid = len(block) // 2
        left = block[:mid]
        right = block[mid:]

        for i in range(11, -1, -1):
            round_key = self.cipher_key[:16] + i.to_bytes(4, 'big')

            old_right = left
            combined = old_right.encode('utf-8') + round_key
            prf_output = hmac.new(self.cipher_key, combined, sha256).digest()
            prf_num = int.from_bytes(prf_output, 'big')
            
            round_factor = (i + 1) % self.alphabet_size
            if round_factor == 0:
                round_factor = 1
            shift = (prf_num * round_factor) % self.alphabet_size

            old_left = ''
            for ch in right:
                idx = self.shuffled_alphabet.index(ch)
                old_idx = (idx - shift) % self.alphabet_size
                shifted_ch = self.shuffled_alphabet[old_idx]
                original_ch = self._apply_inverse_sbox(shifted_ch)
                old_left += original_ch

            left = old_left
            right = old_right

        return left + right

    def _encode_block(self, block: str) -> str:
        code = 0
        for ch in block:
            code = code * self.alphabet_size + self.shuffled_alphabet.index(ch)
        encoded = self._to_base36(code)
        return encoded.rjust(24, self.base36[0])

    def _decode_block(self, encoded: str) -> str:
        code = self._from_base36(encoded)
        chars = []
        for _ in range(self.block_size):
            code, r = divmod(code, self.alphabet_size)
            chars.append(self.shuffled_alphabet[r])
        decoded = ''.join(reversed(chars))
        return decoded

    def _group(self, s: str, n: int = 6) -> str:
        return ' '.join(s[i:i+n] for i in range(0, len(s), n))

    def encrypt(self, plaintext: str) -> str:
        blocks = self._text_to_blocks(plaintext, self.block_size)

        # ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è IV
        iv_block = ''.join(
            self.shuffled_alphabet[secrets.randbelow(self.alphabet_size)]
            for _ in range(self.block_size)
        )

        prev = iv_block
        ciphertext_blocks = []
        for block in blocks:
            mixed = self._mix_blocks(block, prev)
            feistel_enc = self._feistel_encrypt_block(mixed)
            ct = self._encode_block(feistel_enc)
            ciphertext_blocks.append(ct)
            prev = feistel_enc

        iv_enc = self._encode_block(iv_block)
        body = iv_enc + ''.join(ciphertext_blocks)

        mac_full = hmac.new(self.mac_key, body.encode('utf-8'), sha256).digest()
        mac_16 = mac_full[:16]
        mac_num = int.from_bytes(mac_16, 'big')
        mac_base36 = self._to_base36(mac_num).rjust(25, self.base36[0])

        body_grouped = self._group(body, 6)
        mac_grouped = self._group(mac_base36, 6)
        return f"{body_grouped} : {mac_grouped}"

    def decrypt(self, ciphertext_with_mac: str) -> str:
        if " : " not in ciphertext_with_mac:
            raise ValueError("–§–æ—Ä–º–∞—Ç: —Ç–µ–ª–æ : mac")

        body_part, mac_part = ciphertext_with_mac.split(" : ", 1)
        body_clean = body_part.replace(" ", "")
        mac_clean = mac_part.replace(" ", "")

        if len(mac_clean) != 25:
            raise ValueError("MAC –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 25 —Å–∏–º–≤–æ–ª–æ–≤")

        expected_mac_full = hmac.new(self.mac_key, body_clean.encode('utf-8'), sha256).digest()
        expected_mac = expected_mac_full[:16]
        mac_bytes = self._from_base36(mac_clean).to_bytes(16, 'big')
        if not hmac.compare_digest(mac_bytes, expected_mac):
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π MAC!")

        if len(body_clean) < 24 or len(body_clean) % 24 != 0:
            raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ —Ç–µ–ª–∞")

        iv_enc = body_clean[:24]
        ct_enc = body_clean[24:]

        iv_block = self._decode_block(iv_enc)
        prev = iv_block
        plaintext_blocks = []

        for i in range(0, len(ct_enc), 24):
            enc_block = ct_enc[i:i+24]
            feistel_dec = self._decode_block(enc_block)

            mixed = self._feistel_decrypt_block(feistel_dec)

            plain_block = self._unmix_blocks(mixed, prev)

            plaintext_blocks.append(plain_block)
            prev = feistel_dec

        return self._blocks_to_text(plaintext_blocks)

# –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
srpc_instance = None
`;

                // –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–¥ SRPC
                await pyodide.runPythonAsync(srpcCode);
                srpcModule = pyodide.pyimport("__main__");
            } catch (error) {
                console.error('SRPC code loading error:', error);
                throw error;
            }
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
        // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º Python —Ñ—É–Ω–∫—Ü–∏–∏
        async function processSRPC() {
            const inputText = document.getElementById('inputText').value;
            const masterKey = document.getElementById('masterKey').value;
            const mode = document.getElementById('srpcMode').value;
            
            if (!masterKey || masterKey.length < minLength || !inputText) {
                showStatus('–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–≤–æ–¥ –∫–ª—é—á–∞ –∏ —Ç–µ–∫—Å—Ç–∞', 'error');
                return;
            }

            try {
                // –°–æ–∑–¥–∞–µ–º Python —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
                await pyodide.runPythonAsync(`
        def srpc_operation(mode, key, text):
            try:
                cipher = SRPC(key)
                if mode == "encrypt":
                    return cipher.encrypt(text)
                else:
                    return cipher.decrypt(text)
            except Exception as e:
                return f"ERROR: {str(e)}"
        `);
                
                // –í—ã–∑—ã–≤–∞–µ–º Python —Ñ—É–Ω–∫—Ü–∏—é
                const srpc_func = pyodide.globals.get('srpc_operation');
                const result = srpc_func(mode, masterKey, inputText);
                const resultStr = String(result);
                
                document.getElementById('outputText').value = resultStr;
                
                if (resultStr.startsWith('ERROR:')) {
                    showStatus('–û—à–∏–±–∫–∞: ' + resultStr.substring(6), 'error');
                } else {
                    showStatus('–û–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!', 'success');
                }
                
                // –û—á–∏—â–∞–µ–º
                srpc_func.destroy();
                
            } catch (error) {
                console.error('Error:', error);
                showStatus('–û—à–∏–±–∫–∞: ' + error.message, 'error');
            }
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function toggleCipherInfo() {
            const info = document.getElementById('cipher-info');
            const arrow = document.getElementById('cipher-arrow');
            if (info.classList.contains('hidden')) {
                info.classList.remove('hidden');
                arrow.classList.add('rotate-180');
            } else {
                info.classList.add('hidden');
                arrow.classList.remove('rotate-180');
            }
        }

        function updateKeyLength() {
            const key = document.getElementById('masterKey').value;
            const lengthSpan = document.getElementById('key-length');
            const warning = document.getElementById('key-warning');
            
            lengthSpan.textContent = key.length;
            
            if (key.length > 0 && key.length < minLength) {
                warning.classList.remove('hidden');
            } else {
                warning.classList.add('hidden');
            }
        }

        function generateRandomKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
            const length = Math.floor(Math.random() * 11) + 20; // 20-30 —Å–∏–º–≤–æ–ª–æ–≤
            let result = '';
            
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            
            document.getElementById('masterKey').value = result;
            updateKeyLength();
            showKeyStatus(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á (${length} —Å–∏–º–≤–æ–ª–æ–≤)`, 'success');
        }

        function saveKey() {
            const key = document.getElementById('masterKey').value;
            if (!key.trim()) {
                showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º', 'error');
                return;
            }
            if (key.length < minLength) {
                showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤', 'error');
                return;
            }
            try {
                localStorage.setItem('srpc_key', key);
                showKeyStatus('–ö–ª—é—á —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω', 'success');
            } catch (error) {
                showKeyStatus('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
            }
        }

        function loadKey() {
            try {
                const savedKey = localStorage.getItem('srpc_key');
                if (savedKey) {
                    document.getElementById('masterKey').value = savedKey;
                    updateKeyLength();
                    showKeyStatus('–ö–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω', 'success');
                } else {
                    showKeyStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω', 'warning');
                }
            } catch (error) {
                showKeyStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª—é—á–∞', 'error');
            }
        }

        function clearKey() {
            try {
                localStorage.removeItem('srpc_key');
                document.getElementById('masterKey').value = '';
                updateKeyLength();
                showKeyStatus('–ö–ª—é—á —É–¥–∞–ª–µ–Ω', 'info');
            } catch (error) {
                showKeyStatus('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
            }
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            showStatus('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã', 'info');
        }

        async function copyToClipboard() {
            const text = document.getElementById('outputText').value;
            if (!text) {
                showStatus('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'warning');
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                showStatus('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
            } catch (err) {
                showStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
            }
        }

        function swapTexts() {
            const inputText = document.getElementById('inputText');
            const outputText = document.getElementById('outputText');
            const mode = document.getElementById('srpcMode');
            
            [inputText.value, outputText.value] = [outputText.value, inputText.value];
            mode.value = mode.value === 'encrypt' ? 'decrypt' : 'encrypt';
            document.getElementById('processBtn').textContent = mode.value === 'encrypt' ? '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å' : '–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å';
            showStatus('–¢–µ–∫—Å—Ç—ã –ø–æ–º–µ–Ω—è–Ω—ã –º–µ—Å—Ç–∞–º–∏', 'info');
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status-message');
            const statusText = document.getElementById('status-text');
            
            statusText.textContent = message;
            statusDiv.className = 'mb-4 p-4 rounded-lg ';
            
            switch (type) {
                case 'success':
                    statusDiv.classList.add('bg-green-50', 'text-green-700', 'border', 'border-green-200');
                    break;
                case 'error':
                    statusDiv.classList.add('bg-red-50', 'text-red-700', 'border', 'border-red-200');
                    break;
                case 'warning':
                    statusDiv.classList.add('bg-yellow-50', 'text-yellow-700', 'border', 'border-yellow-200');
                    break;
                case 'info':
                    statusDiv.classList.add('bg-blue-50', 'text-blue-700', 'border', 'border-blue-200');
                    break;
            }
            
            statusDiv.classList.remove('hidden');
            
            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }

        function showKeyStatus(message, type) {
            const keyStatus = document.getElementById('key-status');
            keyStatus.textContent = message;
            keyStatus.className = 'text-sm text-center p-2 rounded ';
            
            switch (type) {
                case 'success':
                    keyStatus.classList.add('bg-green-50', 'text-green-700', 'border', 'border-green-200');
                    break;
                case 'error':
                    keyStatus.classList.add('bg-red-50', 'text-red-700', 'border', 'border-red-200');
                    break;
                case 'warning':
                    keyStatus.classList.add('bg-yellow-50', 'text-yellow-700', 'border', 'border-yellow-200');
                    break;
                case 'info':
                    keyStatus.classList.add('bg-blue-50', 'text-blue-700', 'border', 'border-blue-200');
                    break;
            }
            
            keyStatus.classList.remove('hidden');
            
            setTimeout(() => {
                keyStatus.classList.add('hidden');
            }, 3000);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        document.addEventListener('DOMContentLoaded', function() {
            updateKeyLength();
            loadKey();
            initializePyodide();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–µ–∂–∏–º–∞
            document.getElementById('srpcMode').addEventListener('change', function() {
                document.getElementById('processBtn').textContent = 
                    this.value === 'encrypt' ? '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å' : '–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å';
            });
        });
    </script>
</body>
</html>
