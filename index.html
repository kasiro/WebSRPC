<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</h1>
            <p class="text-gray-600">Secure Russian Polygraphic Cipher - –°–æ–≤–º–µ—Å—Ç–∏–º–∞—è –≤–µ—Ä—Å–∏—è</p>
        </header>

        <!-- –°–µ–∫—Ü–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º —à–∏—Ñ—Ä–∞ -->
        <div class="mb-6 bg-white rounded-lg shadow overflow-hidden">
            <div class="bg-blue-500 text-white p-4 cursor-pointer" @click="toggleCipherInfo">
                <div class="flex justify-between items-center">
                    <h2 class="text-xl font-bold">–û —à–∏—Ñ—Ä–µ SRPC</h2>
                    <svg class="w-5 h-5 transform transition-transform" :class="{'rotate-180': !showCipherInfo}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
            </div>
            <div v-if="showCipherInfo" class="p-4 space-y-3">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-800">üìä –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li><strong>–¢–∏–ø:</strong> –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –±–ª–æ—á–Ω—ã–π —à–∏—Ñ—Ä</li>
                            <li><strong>–†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞:</strong> 16 —Å–∏–º–≤–æ–ª–æ–≤</li>
                            <li><strong>–†–µ–∂–∏–º:</strong> CBC (Cipher Block Chaining)</li>
                            <li><strong>–†–∞—É–Ω–¥—ã:</strong> 12 —Ä–∞—É–Ω–¥–æ–≤ Feistel —Å–µ—Ç–∏</li>
                            <li><strong>–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è:</strong> HMAC-SHA256</li>
                            <li><strong>–î–ª–∏–Ω–∞ –∫–ª—é—á–∞:</strong> –æ—Ç 8 —Å–∏–º–≤–æ–ª–æ–≤</li>
                        </ul>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold text-gray-800">üîë –ö–ª—é—á–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li><strong>Cipher Key:</strong> 32 –±–∞–π—Ç–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</li>
                            <li><strong>MAC Key:</strong> 32 –±–∞–π—Ç–∞ –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏</li>
                            <li><strong>–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ:</strong> Base36 —Å –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–æ–π</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è –≤–≤–æ–¥–∞ -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ -->
            <div class="space-y-6">
                <!-- –ü–æ–ª–µ –¥–ª—è —Ç–µ–∫—Å—Ç–∞ -->
                <div class="bg-white rounded-lg shadow">
                    <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                        –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:
                    </label>
                    <textarea 
                        v-model="inputText" 
                        :placeholder="srpcMode === 'encrypt' ? '–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...' : '–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...'"
                        class="w-full h-48 p-4 outline-none resize-none"
                    ></textarea>
                </div>

                <!-- –ü–æ–ª–µ –¥–ª—è –∫–ª—é—á–∞ -->
                <div class="bg-white rounded-lg shadow">
                    <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                        –ú–∞—Å—Ç–µ—Ä-–∫–ª—é—á:
                        <span class="text-xs font-normal text-gray-500 ml-1">
                            (–º–∏–Ω. 8 —Å–∏–º–≤–æ–ª–æ–≤, —Å–µ–π—á–∞—Å: {{ masterKey.length }})
                        </span>
                    </label>
                    <div class="p-4">
                        <input 
                            type="text" 
                            v-model="masterKey" 
                            placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (–º–∏–Ω–∏–º—É–º 20 —Å–∏–º–≤–æ–ª–æ–≤)"
                            class="w-full p-3 border border-gray-300 rounded-md"
                            :class="{'border-red-500': masterKey.length > 0 && masterKey.length < 20}"
                            @input="generateDerivedKeys"
                        >
                        
                        <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–ª—é—á–æ–º -->
                        <div class="mt-3 grid grid-cols-2 gap-2">
                            <button 
                                @click="saveKey"
                                class="px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üíæ</span>
                                <span>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</span>
                            </button>
                            <button 
                                @click="loadKey"
                                class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üìÇ</span>
                                <span>–ó–∞–≥—Ä—É–∑–∏—Ç—å</span>
                            </button>
                            <button 
                                @click="generateRandomKey"
                                class="px-3 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üé≤</span>
                                <span>–°–ª—É—á–∞–π–Ω—ã–π</span>
                            </button>
                            <button 
                                @click="clearKey"
                                class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                            >
                                <span>üóëÔ∏è</span>
                                <span>–û—á–∏—Å—Ç–∏—Ç—å</span>
                            </button>
                        </div>

                        <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –∫–æ—Ä–æ—Ç–∫–æ–º –∫–ª—é—á–µ -->
                        <div v-if="masterKey.length > 0 && masterKey.length < 20" class="mt-2 text-sm text-red-600 text-center">
                            ‚ö†Ô∏è –ö–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π! –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ - 20 —Å–∏–º–≤–æ–ª–æ–≤.
                        </div>
                    </div>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
            <div class="space-y-6">
                <!-- –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏ -->
                <div class="bg-white rounded-lg shadow">
                    <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                        –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏:
                    </label>
                    <div class="p-4 space-y-4">
                        <!-- Cipher Key -->
                        <div>
                            <label class="block text-xs font-medium text-gray-500 mb-1">Cipher Key (—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ):</label>
                            <div class="flex items-center space-x-2">
                                <input 
                                    type="text" 
                                    v-model="cipherKey" 
                                    readonly
                                    class="flex-1 p-2 bg-gray-50 border border-gray-200 rounded text-sm font-mono"
                                >
                                <button 
                                    @click="copyCipherKey"
                                    class="px-3 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors text-xs"
                                >
                                    üìã
                                </button>
                            </div>
                            <div class="text-xs text-gray-500 mt-1">{{ cipherKey.length / 2 }} –±–∞–π—Ç</div>
                        </div>

                        <!-- MAC Key -->
                        <div>
                            <label class="block text-xs font-medium text-gray-500 mb-1">MAC Key (–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è):</label>
                            <div class="flex items-center space-x-2">
                                <input 
                                    type="text" 
                                    v-model="macKey" 
                                    readonly
                                    class="flex-1 p-2 bg-gray-50 border border-gray-200 rounded text-sm font-mono"
                                >
                                <button 
                                    @click="copyMacKey"
                                    class="px-3 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors text-xs"
                                >
                                    üìã
                                </button>
                            </div>
                            <div class="text-xs text-gray-500 mt-1">{{ macKey.length / 2 }} –±–∞–π—Ç</div>
                        </div>
                    </div>
                </div>

                <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å—Ç–∞—Ç—É—Å -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="space-y-4">
                        <!-- –†–µ–∂–∏–º -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">–†–µ–∂–∏–º:</label>
                            <select v-model="srpcMode" class="w-full p-2 border border-gray-300 rounded-md">
                                <option value="encrypt">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                                <option value="decrypt">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                            </select>
                        </div>

                        <!-- –ö–Ω–æ–ø–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è -->
                        <div class="flex space-x-3">
                            <button 
                                @click="processSRPC"
                                :disabled="masterKey.length < 20"
                                class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                            >
                                {{ srpcMode === 'encrypt' ? '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å' : '–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å' }}
                            </button>
                            <button 
                                @click="clearAll"
                                class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors"
                            >
                                –û—á–∏—Å—Ç–∏—Ç—å
                            </button>
                        </div>

                        <!-- –°—Ç–∞—Ç—É—Å –∫–ª—é—á–µ–π -->
                        <div v-if="keyStatus" class="text-sm text-center p-2 rounded" :class="keyStatusClass">
                            {{ keyStatus }}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç -->
        <div class="bg-white rounded-lg shadow mb-6">
            <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                –†–µ–∑—É–ª—å—Ç–∞—Ç:
            </label>
            <textarea 
                v-model="outputText" 
                placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç..."
                readonly
                class="w-full h-48 p-4 outline-none resize-none font-mono text-sm"
            ></textarea>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏ -->
        <div v-if="statusMessage" class="mb-4 p-4 rounded-lg" :class="statusClass">
            <p class="text-sm font-medium">{{ statusMessage }}</p>
        </div>

        <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è -->
        <div class="flex justify-center space-x-4">
            <button 
                @click="copyToClipboard"
                class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors"
            >
                –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            </button>
            <button 
                @click="swapTexts"
                class="px-6 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors"
            >
                –ü–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
            </button>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, watch } = Vue;

        createApp({
            setup() {
                const inputText = ref('');
                const outputText = ref('');
                const masterKey = ref('test_reversibility_extended_key_has_crypto');
                const cipherKey = ref('');
                const macKey = ref('');
                const srpcMode = ref('encrypt');
                const statusMessage = ref('');
                const statusClass = ref('bg-blue-50 text-blue-700');
                const showCipherInfo = ref(false);
                const keyStatus = ref('');
                const keyStatusClass = ref('text-gray-600');

                // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∫–∞–∫ –≤ Python –≤–µ—Ä—Å–∏–∏
                const SALT = "srpc_v2_salt_2024_secure_random_bytes";
                const BLOCK_SIZE = 16;
                const ROUNDS = 12;
                const PASS_MIN_LENGTH = 8;

                // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–ª—é—á–∞ –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
                onMounted(() => {
                    loadKeyOnStart();
                });

                // –°–ª–µ–¥–∏–º –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á–∞
                watch(masterKey, () => {
                    generateDerivedKeys();
                });

                const generateDerivedKeys = () => {
                    if (!masterKey.value || masterKey.value.length < PASS_MIN_LENGTH) {
                        cipherKey.value = '';
                        macKey.value = '';
                        return;
                    }

                    try {
                        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π –∫–∞–∫ –≤ Python –≤–µ—Ä—Å–∏–∏
                        const saltedKey = masterKey.value + SALT;
                        
                        // Cipher Key
                        const cipherHmac = CryptoJS.HmacSHA256("cipher_key_derivation", saltedKey);
                        cipherKey.value = cipherHmac.toString(CryptoJS.enc.Hex);
                        
                        // MAC Key
                        const macHmac = CryptoJS.HmacSHA256("mac_key_derivation", saltedKey);
                        macKey.value = macHmac.toString(CryptoJS.enc.Hex);
                    } catch (error) {
                        console.error('Key generation error:', error);
                    }
                };

                const loadKeyOnStart = () => {
                    try {
                        const savedKey = localStorage.getItem('srpc_key');
                        if (savedKey) {
                            masterKey.value = savedKey;
                            showKeyStatus('–ö–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏', 'success');
                        }
                    } catch (error) {
                        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–ª—é—á –∏–∑ LocalStorage:', error);
                    }
                };

                const saveKey = () => {
                    if (!masterKey.value.trim()) {
                        showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º', 'error');
                        return;
                    }
                    if (masterKey.value.length < PASS_MIN_LENGTH) {
                        showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤', 'error');
                        return;
                    }
                    try {
                        localStorage.setItem('srpc_key', masterKey.value);
                        showKeyStatus('–ö–ª—é—á —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω', 'success');
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
                        console.error('Save key error:', error);
                    }
                };

                const loadKey = () => {
                    try {
                        const savedKey = localStorage.getItem('srpc_key');
                        if (savedKey) {
                            masterKey.value = savedKey;
                            showKeyStatus('–ö–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω', 'success');
                        } else {
                            showKeyStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω', 'warning');
                        }
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª—é—á–∞', 'error');
                        console.error('Load key error:', error);
                    }
                };

                const clearKey = () => {
                    try {
                        localStorage.removeItem('srpc_key');
                        masterKey.value = '';
                        cipherKey.value = '';
                        macKey.value = '';
                        showKeyStatus('–ö–ª—é—á —É–¥–∞–ª–µ–Ω', 'info');
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
                        console.error('Clear key error:', error);
                    }
                };

                const generateRandomKey = () => {
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
                    const length = Math.floor(Math.random() * 11) + PASS_MIN_LENGTH;
                    let result = '';
                    
                    for (let i = 0; i < length; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    
                    masterKey.value = result;
                    showKeyStatus(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á (${length} —Å–∏–º–≤–æ–ª–æ–≤)`, 'success');
                };

                const copyCipherKey = async () => {
                    try {
                        await navigator.clipboard.writeText(cipherKey.value);
                        showKeyStatus('Cipher Key —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω', 'success');
                    } catch (err) {
                        showKeyStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è Cipher Key', 'error');
                    }
                };

                const copyMacKey = async () => {
                    try {
                        await navigator.clipboard.writeText(macKey.value);
                        showKeyStatus('MAC Key —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω', 'success');
                    } catch (err) {
                        showKeyStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è MAC Key', 'error');
                    }
                };

                const showKeyStatus = (message, type) => {
                    keyStatus.value = message;
                    switch (type) {
                        case 'success':
                            keyStatusClass.value = 'bg-green-50 text-green-700 border border-green-200';
                            break;
                        case 'error':
                            keyStatusClass.value = 'bg-red-50 text-red-700 border border-red-200';
                            break;
                        case 'warning':
                            keyStatusClass.value = 'bg-yellow-50 text-yellow-700 border border-yellow-200';
                            break;
                        case 'info':
                            keyStatusClass.value = 'bg-blue-50 text-blue-700 border border-blue-200';
                            break;
                        default:
                            keyStatusClass.value = 'bg-gray-50 text-gray-700 border border-gray-200';
                    }
                    setTimeout(() => {
                        keyStatus.value = '';
                    }, 3000);
                };

                const toggleCipherInfo = () => {
                    showCipherInfo.value = !showCipherInfo.value;
                };

                // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è SRPC —Å Python –≤–µ—Ä—Å–∏–µ–π
                class SRPC {
                    constructor(key) {
                        if (!key) {
                            throw new Error("–ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º");
                        }
                        if (key.length < PASS_MIN_LENGTH) {
                            throw new Error("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤");
                        }

                        this.masterKey = key;
                        this.SALT = "srpc_v2_salt_2024_secure_random_bytes";

                        // –ê–ª—Ñ–∞–≤–∏—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–π Python –≤–µ—Ä—Å–∏–∏
                        this.plainAlphabet = (
                            "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø" +
                            "–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è" +
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                            "abcdefghijklmnopqrstuvwxyz" +
                            "0123456789 \n" +
                            "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
                        );
                        this.alphabetSize = this.plainAlphabet.length;
                        this.base36 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                        this.base36Size = 36;
                        this.blockSize = BLOCK_SIZE;
                        this.rounds = ROUNDS;

                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∫ –≤ Python
                        if (this.alphabetSize ** this.blockSize > this.base36Size ** 24) {
                            throw new Error("–ê–ª—Ñ–∞–≤–∏—Ç —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫ –¥–ª—è 16‚Üí24 —Å—Ö–µ–º—ã");
                        }

                        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π —á–µ—Ä–µ–∑ HMAC-SHA256 —Å —Å–æ–ª—å—é
                        const saltedKey = key + this.SALT;
                        this.cipherKey = CryptoJS.HmacSHA256("cipher_key_derivation", saltedKey).toString(CryptoJS.enc.Hex);
                        this.macKey = CryptoJS.HmacSHA256("mac_key_derivation", saltedKey).toString(CryptoJS.enc.Hex);

                        // –ü–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π –∞–ª—Ñ–∞–≤–∏—Ç –∏ S-Box
                        this.shuffledAlphabet = this._shuffleAlphabet(this.plainAlphabet, this.cipherKey);
                        this.sbox = this._generateSBox(this.cipherKey);
                    }

                    _shuffleAlphabet(alphabet, keyMaterial) {
                        const letters = alphabet.split('');
                        const n = letters.length;
                        const keyBytes = this._hexToBytes(keyMaterial);
                        
                        for (let i = n - 1; i > 0; i--) {
                            const j = keyBytes[i % keyBytes.length] % (i + 1);
                            [letters[i], letters[j]] = [letters[j], letters[i]];
                        }
                        return letters.join('');
                    }

                    _hexToBytes(hex) {
                        const bytes = [];
                        for (let i = 0; i < hex.length; i += 2) {
                            bytes.push(parseInt(hex.substr(i, 2), 16));
                        }
                        return bytes;
                    }

                    _generateSBox(keyMaterial) {
                        const indices = Array.from({length: this.alphabetSize}, (_, i) => i);
                        const keyBytes = this._hexToBytes(keyMaterial);
                        const n = indices.length;

                        for (let i = n - 1; i > 0; i--) {
                            const j = keyBytes[i % keyBytes.length] % (i + 1);
                            [indices[i], indices[j]] = [indices[j], indices[i]];
                        }
                        return indices;
                    }

                    _toBase36(num) {
                        if (num === 0) return this.base36[0];
                        let result = '';
                        let n = BigInt(num);
                        const base = BigInt(this.base36Size);
                        
                        while (n > 0) {
                            const remainder = Number(n % base);
                            result = this.base36[remainder] + result;
                            n = n / base;
                        }
                        return result;
                    }

                    _fromBase36(str) {
                        let num = BigInt(0);
                        const base = BigInt(this.base36Size);
                        
                        for (let i = 0; i < str.length; i++) {
                            const ch = str[i];
                            let val;
                            if (ch >= 'A' && ch <= 'Z') {
                                val = BigInt(ch.charCodeAt(0) - 'A'.charCodeAt(0));
                            } else {
                                val = BigInt(ch.charCodeAt(0) - '0'.charCodeAt(0) + 26);
                            }
                            num = num * base + val;
                        }
                        return num;
                    }

                    _pad(text, blockSize = this.blockSize) {
                        let padLen = blockSize - (text.length % blockSize);
                        if (padLen === 0) {
                            padLen = blockSize;  // –í–æ—Ç —ç—Ç–æ –∫–ª—é—á–µ–≤–æ–µ –æ—Ç–ª–∏—á–∏–µ!
                        }
                        const paddingChar = this.shuffledAlphabet[(padLen - 1) % this.alphabetSize];
                        return text + paddingChar.repeat(padLen);
                    }

                    _unpad(text) {
                        if (!text) return text;
                        const lastChar = text[text.length - 1];
                        const padIdx = this.shuffledAlphabet.indexOf(lastChar);
                        
                        if (padIdx === -1) {
                            throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–∞–¥–¥–∏–Ω–≥–∞");
                        }
                        
                        const padLen = padIdx + 1;
                        
                        // –†–ê–ó–†–ï–®–ò–¢–¨ padLen —Ä–∞–≤–Ω—ã–π blockSize
                        if (padLen < 1 || padLen > this.blockSize) {
                            throw new Error(`–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –ø–∞–¥–¥–∏–Ω–≥–∞ ${padLen} > ${this.blockSize}`);
                        }

                        if (text.length < padLen || text.slice(-padLen) !== lastChar.repeat(padLen)) {
                            throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–∞–¥–¥–∏–Ω–≥");
                        }

                        return text.slice(0, -padLen);
                    }

                    _textToBlocks(text) {
                        const padded = this._pad(text, this.blockSize);
                        const blocks = [];
                        for (let i = 0; i < padded.length; i += this.blockSize) {
                            blocks.push(padded.slice(i, i + this.blockSize));
                        }
                        return blocks;
                    }

                    // _BlocksToText(blocks) {
                    //     return this._unpad();
                    // }

                    _applySbox(ch) {
                        const idx = this.shuffledAlphabet.indexOf(ch);
                        const newIdx = this.sbox[idx];
                        return this.shuffledAlphabet[newIdx];
                    }

                    _applyInverseSbox(ch) {
                        const idx = this.shuffledAlphabet.indexOf(ch);
                        for (let i = 0; i < this.sbox.length; i++) {
                            if (this.sbox[i] === idx) {
                                return this.shuffledAlphabet[i];
                            }
                        }
                        return ch;
                    }

                    _mixBlocks(block, prev) {
                        const alphabet = this.shuffledAlphabet;
                        const n = this.alphabetSize;
                        let result = '';
                        for (let i = 0; i < block.length; i++) {
                            const idx1 = alphabet.indexOf(block[i]);
                            const idx2 = alphabet.indexOf(prev[i]);
                            const mixedIdx = (idx1 + idx2) % n;
                            result += alphabet[mixedIdx];
                        }
                        return result;
                    }

                    _unmixBlocks(mixed, prev) {
                        const alphabet = this.shuffledAlphabet;
                        const n = this.alphabetSize;
                        let result = '';
                        for (let i = 0; i < mixed.length; i++) {
                            const idx1 = alphabet.indexOf(mixed[i]);
                            const idx2 = alphabet.indexOf(prev[i]);
                            const plainIdx = (idx1 - idx2 + n) % n;
                            result += alphabet[plainIdx];
                        }
                        return result;
                    }

                    _feistelRound(left, right, roundKey, roundNum) {
                        const combined = CryptoJS.enc.Utf8.parse(right + CryptoJS.enc.Hex.parse(roundKey));
                        const key = CryptoJS.enc.Hex.parse(this.cipherKey);
                        const hmac = CryptoJS.HmacSHA256(combined, key);
                        const prfOutput = hmac.toString(CryptoJS.enc.Hex);
                        let prfNum = BigInt('0x' + prfOutput);

                        let newLeft = '';
                        for (let i = 0; i < left.length; i++) {
                            const sboxedCh = this._applySbox(left[i]);
                            const idx = this.shuffledAlphabet.indexOf(sboxedCh);
                            
                            const roundFactor = (roundNum + 1) % this.alphabetSize;
                            const shiftFactor = roundFactor === 0 ? 1 : roundFactor;
                            const shift = Number((prfNum * BigInt(shiftFactor)) % BigInt(this.alphabetSize));
                            
                            const newIdx = (idx + shift) % this.alphabetSize;
                            newLeft += this.shuffledAlphabet[newIdx];
                        }
                        return [right, newLeft];
                    }

                    _feistelEncryptBlock(block) {
                        const mid = Math.floor(block.length / 2);
                        let left = block.slice(0, mid);
                        let right = block.slice(mid);

                        for (let i = 0; i < this.rounds; i++) {
                            const roundKey = this.cipherKey.slice(0, 16) + this._intToHex(i, 4);
                            [left, right] = this._feistelRound(left, right, roundKey, i);
                        }
                        return left + right;
                    }

                    _feistelDecryptBlock(block) {
                        const mid = Math.floor(block.length / 2);
                        let left = block.slice(0, mid);
                        let right = block.slice(mid);

                        for (let i = this.rounds - 1; i >= 0; i--) {
                            const roundKey = this.cipherKey.slice(0, 16) + this._intToHex(i, 4);
                            
                            const oldRight = left;
                            const combined = CryptoJS.enc.Utf8.parse(oldRight + CryptoJS.enc.Hex.parse(roundKey));
                            const key = CryptoJS.enc.Hex.parse(this.cipherKey);
                            const hmac = CryptoJS.HmacSHA256(combined, key);
                            const prfOutput = hmac.toString(CryptoJS.enc.Hex);
                            let prfNum = BigInt('0x' + prfOutput);
                            
                            const roundFactor = (i + 1) % this.alphabetSize;
                            const shiftFactor = roundFactor === 0 ? 1 : roundFactor;
                            const shift = Number((prfNum * BigInt(shiftFactor)) % BigInt(this.alphabetSize));

                            let oldLeft = '';
                            for (let j = 0; j < right.length; j++) {
                                const idx = this.shuffledAlphabet.indexOf(right[j]);
                                const oldIdx = (idx - shift + this.alphabetSize) % this.alphabetSize;
                                const shiftedCh = this.shuffledAlphabet[oldIdx];
                                const originalCh = this._applyInverseSbox(shiftedCh);
                                oldLeft += originalCh;
                            }

                            left = oldLeft;
                            right = oldRight;
                        }
                        return left + right;
                    }

                    _intToHex(num, bytes) {
                        let hex = '';
                        for (let i = 0; i < bytes; i++) {
                            const byte = (num >> (8 * (bytes - 1 - i))) & 0xFF;
                            hex += byte.toString(16).padStart(2, '0');
                        }
                        return hex;
                    }

                    _encodeBlock(block) {
                        let code = BigInt(0);
                        for (let i = 0; i < block.length; i++) {
                            code = code * BigInt(this.alphabetSize) + BigInt(this.shuffledAlphabet.indexOf(block[i]));
                        }
                        const encoded = this._toBase36(code);
                        return encoded.padStart(24, this.base36[0]);
                    }

                    _decodeBlock(encoded) {
                        const code = this._fromBase36(encoded);
                        const chars = [];
                        let tempCode = code;
                        for (let i = 0; i < this.blockSize; i++) {
                            const remainder = Number(tempCode % BigInt(this.alphabetSize));
                            chars.unshift(this.shuffledAlphabet[remainder]);
                            tempCode = tempCode / BigInt(this.alphabetSize);
                        }
                        return chars.join('');
                    }

                    _generateIV() {
                        let iv = '';
                        for (let i = 0; i < this.blockSize; i++) {
                            const randomValues = new Uint8Array(2);
                            crypto.getRandomValues(randomValues);
                            const randomIndex = ((randomValues[0] << 8) | randomValues[1]) % this.alphabetSize;
                            iv += this.shuffledAlphabet[randomIndex];
                        }
                        return iv;
                    }

                    _group(s, n = 6) {
                        const chunks = [];
                        for (let i = 0; i < s.length; i += n) {
                            chunks.push(s.slice(i, i + n));
                        }
                        return chunks.join(' ');
                    }

                    encrypt(plaintext) {
                        const blocks = this._textToBlocks(plaintext);
                        const ivBlock = this._generateIV();
                        let prev = ivBlock;
                        const ciphertextBlocks = [];

                        for (const block of blocks) {
                            const mixed = this._mixBlocks(block, prev);
                            const feistelEnc = this._feistelEncryptBlock(mixed);
                            const ct = this._encodeBlock(feistelEnc);
                            ciphertextBlocks.push(ct);
                            prev = feistelEnc;
                        }

                        const ivEnc = this._encodeBlock(ivBlock);
                        const body = ivEnc + ciphertextBlocks.join('');

                        // MAC calculation –∫–∞–∫ –≤ Python
                        const bodyBytes = CryptoJS.enc.Utf8.parse(body);
                        const macKeyBytes = CryptoJS.enc.Hex.parse(this.macKey);
                        const macHmac = CryptoJS.HmacSHA256(bodyBytes, macKeyBytes);
                        const macFull = macHmac.toString(CryptoJS.enc.Hex);
                        const mac16 = macFull.slice(0, 32); // 16 bytes in hex
                        const macNum = BigInt('0x' + mac16);
                        const macBase36 = this._toBase36(macNum).padStart(25, this.base36[0]);

                        // –§–æ—Ä–º–∞—Ç –∫–∞–∫ –≤ Python: {—Ç–µ–ª–æ} : {MAC}
                        const bodyGrouped = this._group(body);
                        const macGrouped = this._group(macBase36);
                        return `${bodyGrouped} : ${macGrouped}`;
                    }

                    decrypt(ciphertextWithMac) {
                        if (!ciphertextWithMac.includes(" : ")) {
                            throw new Error("–§–æ—Ä–º–∞—Ç: —Ç–µ–ª–æ : mac");
                        }

                        const [bodyPart, macPart] = ciphertextWithMac.split(" : ", 2);
                        const bodyClean = bodyPart.replace(/ /g, "");
                        const macClean = macPart.replace(/ /g, "");

                        if (macClean.length !== 25) {
                            throw new Error("MAC –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 25 —Å–∏–º–≤–æ–ª–æ–≤");
                        }

                        // Verify MAC
                        const bodyBytes = CryptoJS.enc.Utf8.parse(bodyClean);
                        const macKeyBytes = CryptoJS.enc.Hex.parse(this.macKey);
                        const expectedMacHmac = CryptoJS.HmacSHA256(bodyBytes, macKeyBytes);
                        const expectedMacFull = expectedMacHmac.toString(CryptoJS.enc.Hex);
                        const expectedMac16 = expectedMacFull.slice(0, 32);
                        const expectedMacNum = BigInt('0x' + expectedMac16);
                        const expectedMacBase36 = this._toBase36(expectedMacNum).padStart(25, this.base36[0]);

                        if (macClean !== expectedMacBase36) {
                            throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π MAC –∏–ª–∏ –∫–ª—é—á!");
                        }

                        if (bodyClean.length < 24 || bodyClean.length % 24 !== 0) {
                            throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ —Ç–µ–ª–∞");
                        }

                        const ivEnc = bodyClean.slice(0, 24);
                        const ctEnc = bodyClean.slice(24);

                        const ivBlock = this._decodeBlock(ivEnc);
                        let prev = ivBlock;
                        const plaintextBlocks = [];

                        for (let i = 0; i < ctEnc.length; i += 24) {
                            const encBlock = ctEnc.slice(i, i + 24);
                            const feistelDec = this._decodeBlock(encBlock);
                            const mixed = this._feistelDecryptBlock(feistelDec);
                            const plainBlock = this._unmixBlocks(mixed, prev);
                            plaintextBlocks.push(plainBlock);
                            prev = feistelDec;
                        }

                        return this._unpad(plaintextBlocks.join(''));
                    }
                }

                const processSRPC = () => {
                    if (!masterKey.value) {
                        showStatus('–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á', 'error');
                        return;
                    }
                    if (masterKey.value.length < PASS_MIN_LENGTH) {
                        showStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤', 'error');
                        return;
                    }

                    generateDerivedKeys();

                    try {
                        const cipher = new SRPC(masterKey.value);
                        
                        if (srpcMode.value === 'encrypt') {
                            outputText.value = cipher.encrypt(inputText.value);
                            showStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω', 'success');
                        } else {
                            outputText.value = cipher.decrypt(inputText.value);
                            showStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω', 'success');
                        }
                    } catch (error) {
                        showStatus('–û—à–∏–±–∫–∞: ' + error.message, 'error');
                        outputText.value = '';
                        console.error('SRPC Error:', error);
                    }
                };

                const showStatus = (message, type) => {
                    statusMessage.value = message;
                    switch (type) {
                        case 'success':
                            statusClass.value = 'bg-green-50 text-green-700 border border-green-200';
                            break;
                        case 'error':
                            statusClass.value = 'bg-red-50 text-red-700 border border-red-200';
                            break;
                        default:
                            statusClass.value = 'bg-blue-50 text-blue-700 border border-blue-200';
                    }
                    setTimeout(() => {
                        statusMessage.value = '';
                    }, 5000);
                };

                const copyToClipboard = async () => {
                    try {
                        await navigator.clipboard.writeText(outputText.value);
                        showStatus('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
                    } catch (err) {
                        showStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
                    }
                };

                const swapTexts = () => {
                    [inputText.value, outputText.value] = [outputText.value, inputText.value];
                    srpcMode.value = srpcMode.value === 'encrypt' ? 'decrypt' : 'encrypt';
                    showStatus('–¢–µ–∫—Å—Ç—ã –ø–æ–º–µ–Ω—è–Ω—ã –º–µ—Å—Ç–∞–º–∏', 'info');
                };

                const clearAll = () => {
                    inputText.value = '';
                    outputText.value = '';
                    showStatus('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã', 'info');
                };

                return {
                    inputText,
                    outputText,
                    masterKey,
                    cipherKey,
                    macKey,
                    srpcMode,
                    statusMessage,
                    statusClass,
                    showCipherInfo,
                    keyStatus,
                    keyStatusClass,
                    processSRPC,
                    copyToClipboard,
                    swapTexts,
                    clearAll,
                    toggleCipherInfo,
                    saveKey,
                    loadKey,
                    clearKey,
                    generateRandomKey,
                    copyCipherKey,
                    copyMacKey,
                    generateDerivedKeys
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
