<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="container mx-auto p-4">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">SRPC –®–∏—Ñ—Ä–æ–≤–∞–ª—å—â–∏–∫</h1>
            <p class="text-gray-600">Secure Russian Polygraphic Cipher - –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è</p>
        </header>

        <!-- –°–µ–∫—Ü–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º —à–∏—Ñ—Ä–∞ -->
        <div class="mb-6 bg-white rounded-lg shadow overflow-hidden">
            <div class="bg-blue-500 text-white p-4 cursor-pointer" @click="toggleCipherInfo">
                <div class="flex justify-between items-center">
                    <h2 class="text-xl font-bold">–û —à–∏—Ñ—Ä–µ SRPC</h2>
                    <svg class="w-5 h-5 transform transition-transform" :class="{'rotate-180': !showCipherInfo}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
            </div>
            <div v-if="showCipherInfo" class="p-4 space-y-3">
                <div>
                    <h3 class="font-semibold text-gray-800">–ß—Ç–æ —Ç–∞–∫–æ–µ SRPC?</h3>
                    <p class="text-gray-600 text-sm">Secure Russian Polygraphic Cipher - —ç—Ç–æ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –±–ª–æ—á–Ω—ã–π —à–∏—Ñ—Ä, —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π —Å –∞–∫—Ü–µ–Ω—Ç–æ–º –Ω–∞ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç—å –∏ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å —Ä—É—Å—Å–∫–∏–º —Ç–µ–∫—Å—Ç–æ–º.</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-800">üìä –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li><strong>–¢–∏–ø:</strong> –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –±–ª–æ—á–Ω—ã–π —à–∏—Ñ—Ä</li>
                            <li><strong>–†–∞–∑–º–µ—Ä –±–ª–æ–∫–∞:</strong> 4 —Å–∏–º–≤–æ–ª–∞</li>
                            <li><strong>–†–µ–∂–∏–º:</strong> CBC (Cipher Block Chaining)</li>
                            <li><strong>–†–∞—É–Ω–¥—ã:</strong> 8 —Ä–∞—É–Ω–¥–æ–≤ Feistel —Å–µ—Ç–∏</li>
                            <li><strong>–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è:</strong> HMAC-SHA256</li>
                            <li><strong>–î–ª–∏–Ω–∞ –∫–ª—é—á–∞:</strong> –æ—Ç 20 —Å–∏–º–≤–æ–ª–æ–≤</li>
                        </ul>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold text-gray-800">üõ°Ô∏è –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤—ã:</h3>
                        <ul class="text-gray-600 text-sm list-disc list-inside space-y-1">
                            <li>HMAC-SHA256 –¥–ª—è PRF –∏ MAC</li>
                            <li>–°–ª—É—á–∞–π–Ω—ã–µ S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞</li>
                            <li>–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π –∞–ª—Ñ–∞–≤–∏—Ç</li>
                            <li>Base36 –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ</li>
                            <li>–ü–∞–¥–¥–∏–Ω–≥ –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—É PKCS#7</li>
                        </ul>
                    </div>
                </div>

                <div>
                    <h3 class="font-semibold text-gray-800">üîê –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ:</h3>
                    <ol class="text-gray-600 text-sm list-decimal list-inside space-y-1">
                        <li><strong>–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–ª—é—á–µ–π:</strong> –ò–∑ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è cipherKey –∏ macKey —á–µ—Ä–µ–∑ HMAC-SHA256</li>
                        <li><strong>–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:</strong> –°–æ–∑–¥–∞–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (IV)</li>
                        <li><strong>–û–±—Ä–∞–±–æ—Ç–∫–∞ –±–ª–æ–∫–æ–≤:</strong> –¢–µ–∫—Å—Ç —Ä–∞–∑–±–∏–≤–∞–µ—Ç—Å—è –Ω–∞ –±–ª–æ–∫–∏ –ø–æ 4 —Å–∏–º–≤–æ–ª–∞ —Å –ø–∞–¥–¥–∏–Ω–≥–æ–º</li>
                        <li><strong>CBC —Ä–µ–∂–∏–º:</strong> –ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Å–º–µ—à–∏–≤–∞–µ—Ç—Å—è —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–æ–º</li>
                        <li><strong>Feistel —Å–µ—Ç—å:</strong> 8 —Ä–∞—É–Ω–¥–æ–≤ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å HMAC-SHA256 –∫–∞–∫ PRF</li>
                        <li><strong>–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ:</strong> –ë–ª–æ–∫–∏ –∫–æ–¥–∏—Ä—É—é—Ç—Å—è –≤ Base36</li>
                        <li><strong>–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è:</strong> –í—ã—á–∏—Å–ª—è–µ—Ç—Å—è MAC –¥–ª—è –≤—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è</li>
                    </ol>
                </div>

                <div>
                    <h3 class="font-semibold text-gray-800">üìù –§–æ—Ä–º–∞—Ç —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–∞:</h3>
                    <p class="text-gray-600 text-sm font-mono bg-gray-100 p-2 rounded">
                        [{IV}{–ë–ª–æ–∫1}{–ë–ª–æ–∫2}..., {MAC}]
                    </p>
                    <p class="text-gray-600 text-sm mt-1">
                        –ì–¥–µ IV - 4 —Å–∏–º–≤–æ–ª–æ–≤ –≤–µ–∫—Ç–æ—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏, –±–ª–æ–∫–∏ - –ø–æ 4 —Å–∏–º–≤–æ–ª–æ–≤ –∫–∞–∂–¥—ã–π, MAC - 27 —Å–∏–º–≤–æ–ª–æ–≤ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞.
                    </p>
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-3">
                    <p class="text-yellow-700 text-sm">
                        <strong>‚ö†Ô∏è –í–∞–∂–Ω–æ:</strong> –î–ª—è —É—Å–ø–µ—à–Ω–æ–≥–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—Ç –∂–µ –∫–ª—é—á, —á—Ç–æ –∏ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏. 
                        –®–∏—Ñ—Ä –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∫–∞–∫ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å, —Ç–∞–∫ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö.
                        —ç—Ç–æ –∑–Ω–∞—á–∏—Ç –µ—Å–ª–∏ –ø—Ä–∏ —Ä–∞—Å—Å—à–∏—Ñ—Ä–æ–≤–∫–µ –≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π MAC –∏–ª–∏ –∫–ª—é—á
                        –∑–Ω–∞—á–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —Å –¥—Ä—É–≥–∏–º –∫–ª—é—á–æ–º –∏–ª–∏ –ø–æ–¥–º–µ–Ω–µ–Ω–æ
                        –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –µ—Å—Ç—å —à–∞–Ω—Å —Ç–æ–≥–æ —á—Ç–æ –∫—Ç–æ —Ç–æ –ø—ã—Ç–∞–µ—Ç—Å—è
                        –∏–∑–º–µ–Ω–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≤–∞—à–µ–π –ø–µ—Ä–µ–ø–∏—Å–∫–µ, –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ —Å–º–µ–Ω–∏—Ç—å
                        –∏–ª–∏ —É–≤–µ–ª–∏—á–∏—Ç—å –¥–ª–∏–Ω–Ω—É –∫–ª—é—á–∞
                    </p>
                </div>
            </div>
        </div>

        <div class="mb-4 bg-white rounded-lg shadow">
            <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:
            </label>
            <textarea 
                v-model="inputText" 
                placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..."
                class="w-full h-32 p-4 outline-none resize-none"
            ></textarea>
        </div>

        <div class="my-7 p-6 bg-white rounded-lg shadow">
            <div class="space-y-4">
                <h3 class="text-lg font-semibold text-gray-800">SRPC - –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            –ö–ª—é—á: 
                            <span class="text-xs font-normal text-gray-500 ml-1">
                                (–º–∏–Ω. 20 —Å–∏–º–≤–æ–ª–æ–≤, —Å–µ–π—á–∞—Å: {{ srpcKey.length }})
                            </span>
                        </label>
                        <div class="w-full">
                            <input 
                                type="text" 
                                v-model="srpcKey" 
                                placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (–º–∏–Ω–∏–º—É–º 20 —Å–∏–º–≤–æ–ª–æ–≤)"
                                class="w-full flex-1 p-2 border border-gray-300 rounded-md"
                                :class="{'border-red-500': srpcKey.length > 0 && srpcKey.length < 20}"
                            >
                            
                            <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–ª—é—á–æ–º –≤ —Å–µ—Ç–∫–µ 2x3 -->
                            <div class="mt-2 grid grid-cols-2 gap-2">
                                <!-- –ü–µ—Ä–≤—ã–π —Ä—è–¥ -->
                                <button 
                                    @click="saveKey"
                                    class="px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–ª—é—á"
                                >
                                    <span>üíæ</span>
                                    <span>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</span>
                                </button>
                                <button 
                                    @click="loadKey"
                                    class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–ª—é—á"
                                >
                                    <span>üìÇ</span>
                                    <span>–ó–∞–≥—Ä—É–∑–∏—Ç—å</span>
                                </button>
                                
                                <!-- –í—Ç–æ—Ä–æ–π —Ä—è–¥ -->
                                <button 
                                    @click="generateRandomKey"
                                    class="px-3 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á"
                                >
                                    <span>üé≤</span>
                                    <span>–°–ª—É—á–∞–π–Ω—ã–π</span>
                                </button>
                                <button 
                                    @click="copyKey"
                                    class="px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á"
                                >
                                    <span>üìã</span>
                                    <span>–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</span>
                                </button>
                                
                                <!-- –¢—Ä–µ—Ç–∏–π —Ä—è–¥ -->
                                <button 
                                    @click="setSystemKey"
                                    class="px-3 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –∫–ª—é—á"
                                >
                                    <span>‚öôÔ∏è</span>
                                    <span>–°–∏—Å—Ç–µ–º–Ω—ã–π</span>
                                </button>
                                <button 
                                    @click="clearKey"
                                    class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors flex items-center justify-center space-x-1 text-sm"
                                    title="–£–¥–∞–ª–∏—Ç—å –∫–ª—é—á"
                                >
                                    <span>üóëÔ∏è</span>
                                    <span>–£–¥–∞–ª–∏—Ç—å</span>
                                </button>
                            </div>
                        </div>
                        
                        <!-- –°–æ–æ–±—â–µ–Ω–∏—è –æ —Å—Ç–∞—Ç—É—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –∫–ª—é—á–æ–º -->
                        <div v-if="keyStatus" class="mt-2 text-sm text-center" :class="keyStatusClass">
                            {{ keyStatus }}
                        </div>
                        
                        <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –∫–æ—Ä–æ—Ç–∫–æ–º –∫–ª—é—á–µ -->
                        <div v-if="srpcKey.length > 0 && srpcKey.length < 20" class="mt-2 text-sm text-red-600 text-center">
                            ‚ö†Ô∏è –ö–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π! –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ - 20 —Å–∏–º–≤–æ–ª–æ–≤.
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">–†–µ–∂–∏–º:</label>
                        <select v-model="srpcMode" class="w-full p-2 border border-gray-300 rounded-md">
                            <option value="encrypt">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                            <option value="decrypt">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</option>
                        </select>
                    </div>
                </div>

                <div class="flex space-x-4">
                    <button 
                        @click="processSRPC"
                        :disabled="srpcKey.length < 20"
                        class="px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                    >
                        –í—ã–ø–æ–ª–Ω–∏—Ç—å
                    </button>
                    <button 
                        @click="clearAll"
                        class="px-6 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors"
                    >
                        –û—á–∏—Å—Ç–∏—Ç—å
                    </button>
                </div>
            </div>
        </div>

        <div class="mt-4 bg-white rounded-lg shadow">
            <label class="block p-4 border-b border-gray-200 text-sm font-medium text-gray-700">
                –†–µ–∑—É–ª—å—Ç–∞—Ç:
            </label>
            <textarea 
                v-model="outputText" 
                placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç..."
                readonly
                class="w-full h-32 p-4 outline-none resize-none"
            ></textarea>
        </div>

        <div v-if="statusMessage" class="mt-4 p-4 rounded-lg" :class="statusClass">
            <p class="text-sm font-medium">{{ statusMessage }}</p>
        </div>

        <div class="mt-6 flex justify-center space-x-4">
            <button 
                @click="copyToClipboard"
                class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors"
            >
                –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            </button>
            <button 
                @click="swapTexts"
                class="px-6 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors"
            >
                –ü–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
            </button>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted } = Vue;

        createApp({
            setup() {
                const inputText = ref('');
                const outputText = ref('');
                const srpcKey = ref('test_reversibility_extended_key_has_crypto');
                const srpcMode = ref('encrypt');
                const statusMessage = ref('');
                const statusClass = ref('bg-blue-50 text-blue-700');
                const showCipherInfo = ref(false);
                const keyStatus = ref('');
                const keyStatusClass = ref('text-gray-600');

                // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–ª—é—á–∞ –∏–∑ LocalStorage –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
                onMounted(() => {
                    loadKeyOnStart();
                });

                const loadKeyOnStart = () => {
                    try {
                        const savedKey = localStorage.getItem('srpc_key');
                        if (savedKey) {
                            srpcKey.value = savedKey;
                            showKeyStatus('–ö–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏', 'success');
                        }
                    } catch (error) {
                        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–ª—é—á –∏–∑ LocalStorage:', error);
                    }
                };

                const saveKey = () => {
                    if (!srpcKey.value.trim()) {
                        showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º', 'error');
                        return;
                    }
                    if (srpcKey.value.length < 20) {
                        showKeyStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤', 'error');
                        return;
                    }
                    try {
                        localStorage.setItem('srpc_key', srpcKey.value);
                        showKeyStatus('–ö–ª—é—á —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω', 'success');
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
                        console.error('Save key error:', error);
                    }
                };

                const loadKey = () => {
                    try {
                        const savedKey = localStorage.getItem('srpc_key');
                        if (savedKey) {
                            srpcKey.value = savedKey;
                            showKeyStatus('–ö–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω', 'success');
                        } else {
                            showKeyStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω', 'warning');
                        }
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª—é—á–∞', 'error');
                        console.error('Load key error:', error);
                    }
                };

                const clearKey = () => {
                    try {
                        localStorage.removeItem('srpc_key');
                        srpcKey.value = '';
                        showKeyStatus('–ö–ª—é—á —É–¥–∞–ª–µ–Ω', 'info');
                    } catch (error) {
                        showKeyStatus('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–ª—é—á–∞', 'error');
                        console.error('Clear key error:', error);
                    }
                };

                const generateRandomKey = () => {
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
                    const length = Math.floor(Math.random() * 6) + 20; // 20-25 —Å–∏–º–≤–æ–ª–æ–≤
                    let result = '';
                    
                    for (let i = 0; i < length; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    
                    srpcKey.value = result;
                    showKeyStatus(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á (${length} —Å–∏–º–≤–æ–ª–æ–≤)`, 'success');
                };

                const copyKey = async () => {
                    if (!srpcKey.value.trim()) {
                        showKeyStatus('–û—à–∏–±–∫–∞: –ù–µ—Ç –∫–ª—é—á–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(srpcKey.value);
                        showKeyStatus('–ö–ª—é—á —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
                    } catch (err) {
                        showKeyStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∫–ª—é—á–∞', 'error');
                    }
                };

                const setSystemKey = () => {
                    const systemKey = 'test_reversibility_extended_key_has_crypto';
                    srpcKey.value = systemKey;
                    showKeyStatus('–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–∏—Å—Ç–µ–º–Ω—ã–π –∫–ª—é—á', 'info');
                };

                const showKeyStatus = (message, type) => {
                    keyStatus.value = message;
                    switch (type) {
                        case 'success':
                            keyStatusClass.value = 'text-green-600';
                            break;
                        case 'error':
                            keyStatusClass.value = 'text-red-600';
                            break;
                        case 'warning':
                            keyStatusClass.value = 'text-yellow-600';
                            break;
                        case 'info':
                            keyStatusClass.value = 'text-blue-600';
                            break;
                        default:
                            keyStatusClass.value = 'text-gray-600';
                    }
                    setTimeout(() => {
                        keyStatus.value = '';
                    }, 3000);
                };

                const toggleCipherInfo = () => {
                    showCipherInfo.value = !showCipherInfo.value;
                };

                // –ü–æ–ª–Ω–∞—è –∏–¥–µ–Ω—Ç–∏—á–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è SRPC –Ω–∞ JavaScript
                class SRPC {
                    constructor(key) {
                        if (!key) {
                            throw new Error("–ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º");
                        }
                        if (key.length < 20) {
                            throw new Error("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤");
                        }
                        this.masterKey = key;

                        // –ê–ª—Ñ–∞–≤–∏—Ç —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ Python
                        this.plainAlphabet = (
                            "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø" +
                            "–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è" +
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                            "abcdefghijklmnopqrstuvwxyz" +
                            "0123456789 \n" +
                            "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
                        );
                        this.alphabetSize = this.plainAlphabet.length;
                        this.base36 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                        this.base36Size = 36;

                        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π —á–µ—Ä–µ–∑ HMAC-SHA256 –∫–∞–∫ –≤ Python
                        this.cipherKey = this._hmacSha256(key, "cipher");
                        this.macKey = this._hmacSha256(key, "mac");

                        // –ü–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π –∞–ª—Ñ–∞–≤–∏—Ç
                        this.shuffledAlphabet = this._shuffleAlphabet(this.plainAlphabet, this.cipherKey);
                        this.sbox = this._generateSBox(this.cipherKey);
                    }

                    _hmacSha256(key, message) {
                        const hmac = CryptoJS.HmacSHA256(message, key);
                        return hmac.toString(CryptoJS.enc.Hex);
                    }

                    _shuffleAlphabet(alphabet, keyMaterial) {
                        const letters = alphabet.split('');
                        const n = letters.length;
                        const keyBytes = this._hexToBytes(keyMaterial);
                        
                        for (let i = n - 1; i > 0; i--) {
                            const j = keyBytes[i % keyBytes.length] % (i + 1);
                            [letters[i], letters[j]] = [letters[j], letters[i]];
                        }
                        return letters.join('');
                    }

                    _hexToBytes(hex) {
                        const bytes = [];
                        for (let i = 0; i < hex.length; i += 2) {
                            bytes.push(parseInt(hex.substr(i, 2), 16));
                        }
                        return bytes;
                    }

                    _generateSBox(keyMaterial) {
                        const indices = Array.from({length: this.alphabetSize}, (_, i) => i);
                        const keyBytes = this._hexToBytes(keyMaterial);
                        const n = indices.length;

                        for (let i = n - 1; i > 0; i--) {
                            const j = keyBytes[i % keyBytes.length] % (i + 1);
                            [indices[i], indices[j]] = [indices[j], indices[i]];
                        }
                        return indices;
                    }

                    _toBase36(num) {
                        if (num === 0) return this.base36[0];
                        let result = '';
                        let n = num;
                        while (n > 0) {
                            result = this.base36[n % this.base36Size] + result;
                            n = Math.floor(n / this.base36Size);
                        }
                        return result;
                    }

                    _fromBase36(str) {
                        let num = 0;
                        for (let i = 0; i < str.length; i++) {
                            const ch = str[i];
                            let val;
                            if (ch >= 'A' && ch <= 'Z') {
                                val = ch.charCodeAt(0) - 'A'.charCodeAt(0);
                            } else {
                                val = ch.charCodeAt(0) - '0'.charCodeAt(0) + 26;
                            }
                            num = num * this.base36Size + val;
                        }
                        return num;
                    }

                    _pad(text) {
                        const blockSize = 4;
                        const padLen = blockSize - (text.length % blockSize);
                        const paddingChar = this.shuffledAlphabet[(padLen - 1) % this.alphabetSize];
                        return text + paddingChar.repeat(padLen);
                    }

                    _unpad(text) {
                        if (!text) return text;
                        const lastChar = text[text.length - 1];
                        const padIdx = this.shuffledAlphabet.indexOf(lastChar);
                        const padLen = padIdx + 1;
                        
                        if (text.length >= padLen && text.slice(-padLen) === lastChar.repeat(padLen)) {
                            return text.slice(0, -padLen);
                        }
                        return text;
                    }

                    _textToBlocks(text) {
                        const blockSize = 4;
                        const padded = this._pad(text);
                        const blocks = [];
                        for (let i = 0; i < padded.length; i += blockSize) {
                            blocks.push(padded.slice(i, i + blockSize));
                        }
                        return blocks;
                    }

                    _applySbox(ch) {
                        const idx = this.shuffledAlphabet.indexOf(ch);
                        const newIdx = this.sbox[idx];
                        return this.shuffledAlphabet[newIdx];
                    }

                    _applyInverseSbox(ch) {
                        const idx = this.shuffledAlphabet.indexOf(ch);
                        for (let i = 0; i < this.sbox.length; i++) {
                            if (this.sbox[i] === idx) {
                                return this.shuffledAlphabet[i];
                            }
                        }
                        return ch;
                    }

                    _mixBlocks(block, prev) {
                        const alphabet = this.shuffledAlphabet;
                        const n = this.alphabetSize;
                        let result = '';
                        for (let i = 0; i < block.length; i++) {
                            const idx1 = alphabet.indexOf(block[i]);
                            const idx2 = alphabet.indexOf(prev[i]);
                            const mixedIdx = (idx1 + idx2) % n;
                            result += alphabet[mixedIdx];
                        }
                        return result;
                    }

                    _unmixBlocks(mixed, prev) {
                        const alphabet = this.shuffledAlphabet;
                        const n = this.alphabetSize;
                        let result = '';
                        for (let i = 0; i < mixed.length; i++) {
                            const idx1 = alphabet.indexOf(mixed[i]);
                            const idx2 = alphabet.indexOf(prev[i]);
                            const plainIdx = (idx1 - idx2 + n) % n;
                            result += alphabet[plainIdx];
                        }
                        return result;
                    }

                    _feistelRound(left, right, roundKey) {
                        const combined = CryptoJS.enc.Utf8.parse(right + roundKey);
                        const key = CryptoJS.enc.Hex.parse(this.cipherKey);
                        const hmac = CryptoJS.HmacSHA256(combined, key);
                        const prfOutput = hmac.toString(CryptoJS.enc.Hex);
                        
                        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º hex –≤ BigInt
                        let prfNum = BigInt('0x' + prfOutput);

                        let newLeft = '';
                        for (let i = 0; i < left.length; i++) {
                            const sboxedCh = this._applySbox(left[i]);
                            const idx = this.shuffledAlphabet.indexOf(sboxedCh);
                            const shift = Number(prfNum % BigInt(this.alphabetSize));
                            const newIdx = (idx + shift) % this.alphabetSize;
                            newLeft += this.shuffledAlphabet[newIdx];
                        }
                        return [right, newLeft];
                    }

                    _feistelEncryptBlock(block) {
                        const mid = Math.floor(block.length / 2);
                        let left = block.slice(0, mid);
                        let right = block.slice(mid);

                        for (let i = 0; i < 8; i++) {
                            const roundKey = this.cipherKey.slice(0, 32) + this._intToHex(i, 4);
                            [left, right] = this._feistelRound(left, right, roundKey);
                        }
                        return left + right;
                    }

                    _feistelDecryptBlock(block) {
                        const mid = Math.floor(block.length / 2);
                        let left = block.slice(0, mid);
                        let right = block.slice(mid);

                        for (let i = 7; i >= 0; i--) {
                            const roundKey = this.cipherKey.slice(0, 32) + this._intToHex(i, 4);
                            
                            const oldRight = left;
                            const combined = CryptoJS.enc.Utf8.parse(oldRight + roundKey);
                            const key = CryptoJS.enc.Hex.parse(this.cipherKey);
                            const hmac = CryptoJS.HmacSHA256(combined, key);
                            const prfOutput = hmac.toString(CryptoJS.enc.Hex);
                            let prfNum = BigInt('0x' + prfOutput);
                            const shift = Number(prfNum % BigInt(this.alphabetSize));

                            let oldLeft = '';
                            for (let j = 0; j < right.length; j++) {
                                const idx = this.shuffledAlphabet.indexOf(right[j]);
                                const oldIdx = (idx - shift + this.alphabetSize) % this.alphabetSize;
                                const shiftedCh = this.shuffledAlphabet[oldIdx];
                                const originalCh = this._applyInverseSbox(shiftedCh);
                                oldLeft += originalCh;
                            }

                            left = oldLeft;
                            right = oldRight;
                        }
                        return left + right;
                    }

                    _intToHex(num, bytes) {
                        let hex = '';
                        for (let i = 0; i < bytes; i++) {
                            const byte = (num >> (8 * (bytes - 1 - i))) & 0xFF;
                            hex += byte.toString(16).padStart(2, '0');
                        }
                        return hex;
                    }

                    _encodeBlock(block) {
                        let code = 0;
                        for (let i = 0; i < block.length; i++) {
                            code = code * this.alphabetSize + this.shuffledAlphabet.indexOf(block[i]);
                        }
                        const encoded = this._toBase36(code);
                        return encoded.padStart(6, this.base36[0]);
                    }

                    _decodeBlock(encoded) {
                        const code = this._fromBase36(encoded);
                        const chars = [];
                        let tempCode = code;
                        for (let i = 0; i < 4; i++) {
                            const remainder = tempCode % this.alphabetSize;
                            chars.unshift(this.shuffledAlphabet[remainder]);
                            tempCode = Math.floor(tempCode / this.alphabetSize);
                        }
                        return chars.join('');
                    }

                    _generateIV() {
                        let iv = '';
                        for (let i = 0; i < 4; i++) {
                            const randomValues = new Uint8Array(2);
                            crypto.getRandomValues(randomValues);
                            const randomIndex = ((randomValues[0] << 8) | randomValues[1]) % this.alphabetSize;
                            iv += this.shuffledAlphabet[randomIndex];
                        }
                        return iv;
                    }

                    encrypt(plaintext) {
                        const blocks = this._textToBlocks(plaintext);
                        const ivBlock = this._generateIV();
                        let prev = ivBlock;
                        const ciphertextBlocks = [];

                        for (const block of blocks) {
                            const mixed = this._mixBlocks(block, prev);
                            const feistelEnc = this._feistelEncryptBlock(mixed);
                            const ct = this._encodeBlock(feistelEnc);
                            ciphertextBlocks.push(ct);
                            prev = feistelEnc;
                        }

                        const ivEnc = this._encodeBlock(ivBlock);
                        const body = ivEnc + ciphertextBlocks.join('');

                        // MAC calculation
                        const bodyBytes = CryptoJS.enc.Utf8.parse(body);
                        const macKeyBytes = CryptoJS.enc.Hex.parse(this.macKey);
                        const macHmac = CryptoJS.HmacSHA256(bodyBytes, macKeyBytes);
                        const macFull = macHmac.toString(CryptoJS.enc.Hex);
                        const mac16 = macFull.slice(0, 32); // 16 bytes in hex
                        const macNum = BigInt('0x' + mac16);
                        const macBase36 = this._toBase36(Number(macNum % BigInt(36**27))).padStart(27, this.base36[0]);

                        // –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç: [{ct}, {Mac}]
                        return `[${body}, ${macBase36}]`;
                    }

                    decrypt(ciphertextWithMac) {
                        // –ü–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞: [{ct}, {Mac}]
                        const match = ciphertextWithMac.match(/^\[([^,]+),\s*([^\]]+)\]$/);
                        if (!match) {
                            throw new Error("–§–æ—Ä–º–∞—Ç: [{ciphertext}, {mac}]");
                        }

                        const bodyClean = match[1].replace(/ /g, "");
                        const macClean = match[2].replace(/ /g, "");

                        if (macClean.length !== 27) {
                            throw new Error("MAC –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 27 —Å–∏–º–≤–æ–ª–æ–≤");
                        }

                        // Verify MAC
                        const bodyBytes = CryptoJS.enc.Utf8.parse(bodyClean);
                        const macKeyBytes = CryptoJS.enc.Hex.parse(this.macKey);
                        const expectedMacHmac = CryptoJS.HmacSHA256(bodyBytes, macKeyBytes);
                        const expectedMacFull = expectedMacHmac.toString(CryptoJS.enc.Hex);
                        const expectedMac16 = expectedMacFull.slice(0, 32);
                        const expectedMacNum = BigInt('0x' + expectedMac16);
                        const expectedMacBase36 = this._toBase36(Number(expectedMacNum % BigInt(36**27))).padStart(27, this.base36[0]);

                        if (macClean !== expectedMacBase36) {
                            throw new Error("–û—à–∏–±–∫–∞ MAC –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á!");
                        }

                        if (bodyClean.length < 6 || bodyClean.length % 6 !== 0) {
                            throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ —Ç–µ–ª–∞");
                        }

                        const ivEnc = bodyClean.slice(0, 6);
                        const ctEnc = bodyClean.slice(6);

                        const ivBlock = this._decodeBlock(ivEnc);
                        let prev = ivBlock;
                        const plaintextBlocks = [];

                        for (let i = 0; i < ctEnc.length; i += 6) {
                            const encBlock = ctEnc.slice(i, i + 6);
                            const feistelDec = this._decodeBlock(encBlock);
                            const mixed = this._feistelDecryptBlock(feistelDec);
                            const plainBlock = this._unmixBlocks(mixed, prev);
                            plaintextBlocks.push(plainBlock);
                            prev = feistelDec;
                        }

                        return this._unpad(plaintextBlocks.join(''));
                    }
                }

                const processSRPC = () => {
                    if (!srpcKey.value) {
                        showStatus('–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á', 'error');
                        return;
                    }
                    if (srpcKey.value.length < 20) {
                        showStatus('–û—à–∏–±–∫–∞: –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤', 'error');
                        return;
                    }

                    try {
                        const cipher = new SRPC(srpcKey.value);
                        
                        if (srpcMode.value === 'encrypt') {
                            outputText.value = cipher.encrypt(inputText.value);
                            showStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω', 'success');
                        } else {
                            outputText.value = cipher.decrypt(inputText.value);
                            showStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω', 'success');
                        }
                    } catch (error) {
                        showStatus('–û—à–∏–±–∫–∞: ' + error.message, 'error');
                        outputText.value = '';
                        console.error('SRPC Error:', error);
                    }
                };

                const showStatus = (message, type) => {
                    statusMessage.value = message;
                    switch (type) {
                        case 'success':
                            statusClass.value = 'bg-green-50 text-green-700 border border-green-200';
                            break;
                        case 'error':
                            statusClass.value = 'bg-red-50 text-red-700 border border-red-200';
                            break;
                        default:
                            statusClass.value = 'bg-blue-50 text-blue-700 border border-blue-200';
                    }
                    setTimeout(() => {
                        statusMessage.value = '';
                    }, 5000);
                };

                const copyToClipboard = async () => {
                    try {
                        await navigator.clipboard.writeText(outputText.value);
                        showStatus('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
                    } catch (err) {
                        showStatus('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'error');
                    }
                };

                const swapTexts = () => {
                    [inputText.value, outputText.value] = [outputText.value, inputText.value];
                    srpcMode.value = srpcMode.value === 'encrypt' ? 'decrypt' : 'encrypt';
                    showStatus('–¢–µ–∫—Å—Ç—ã –ø–æ–º–µ–Ω—è–Ω—ã –º–µ—Å—Ç–∞–º–∏', 'info');
                };

                const clearAll = () => {
                    inputText.value = '';
                    outputText.value = '';
                    showStatus('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã', 'info');
                };

                return {
                    inputText,
                    outputText,
                    srpcKey,
                    srpcMode,
                    statusMessage,
                    statusClass,
                    showCipherInfo,
                    keyStatus,
                    keyStatusClass,
                    processSRPC,
                    copyToClipboard,
                    swapTexts,
                    clearAll,
                    toggleCipherInfo,
                    saveKey,
                    loadKey,
                    clearKey,
                    generateRandomKey,
                    copyKey,
                    setSystemKey
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
